0x5796698A29F3626c9FE13C4d3d3dEE987c84EBB3
    1 |     | // SPDX-License-Identifier: AGPL-3.0
    2 |     | 
    3 |     | pragma solidity 0.6.12;
    4 |     | pragma experimental ABIEncoderV2;
    5 |     | 
    6 |     | // Global Enums and Structs
    7 |     | 
    8 |     | 
    9 |     | 
   10 |     | struct StrategyParams {
   11 |     |     uint256 performanceFee;
   12 |     |     uint256 activation;
   13 |     |     uint256 debtRatio;
   14 |     |     uint256 minDebtPerHarvest;
   15 |     |     uint256 maxDebtPerHarvest;
   16 |     |     uint256 lastReport;
   17 |     |     uint256 totalDebt;
   18 |     |     uint256 totalGain;
   19 |     |     uint256 totalLoss;
   20 |     | }
   21 |     | 
   22 |     | // Part: IBaseFee
   23 |     | 
   24 |     | interface IBaseFee {
   25 |     |     function basefee_global() external view returns (uint256);
   26 |     | }
   27 |     | 
   28 |     | // Part: IConvexDeposit
   29 |     | 
   30 |     | interface IConvexDeposit {
   31 |     |     // deposit into convex, receive a tokenized deposit.  parameter to stake immediately (we always do this).
   32 |     |     function deposit(
   33 |     |         uint256 _pid,
   34 |     |         uint256 _amount,
   35 |     |         bool _stake
   36 |     |     ) external returns (bool);
   37 |     | 
   38 |     |     // burn a tokenized deposit (Convex deposit tokens) to receive curve lp tokens back
   39 |     |     function withdraw(uint256 _pid, uint256 _amount) external returns (bool);
   40 |     | 
   41 |     |     // give us info about a pool based on its pid
   42 |     |     function poolInfo(uint256)
   43 |     |         external
   44 |     |         view
   45 |     |         returns (
   46 |     |             address,
   47 |     |             address,
   48 |     |             address,
   49 |     |             address,
   50 |     |             address,
   51 |     |             bool
   52 |     |         );
   53 |     | }
   54 |     | 
   55 |     | // Part: IConvexRewards
   56 |     | 
   57 |     | interface IConvexRewards {
   58 |     |     // strategy's staked balance in the synthetix staking contract
   59 |     |     function balanceOf(address account) external view returns (uint256);
   60 |     | 
   61 |     |     // read how much claimable CRV a strategy has
   62 |     |     function earned(address account) external view returns (uint256);
   63 |     | 
   64 |     |     // stake a convex tokenized deposit
   65 |     |     function stake(uint256 _amount) external returns (bool);
   66 |     | 
   67 |     |     // withdraw to a convex tokenized deposit, probably never need to use this
   68 |     |     function withdraw(uint256 _amount, bool _claim) external returns (bool);
   69 |     | 
   70 |     |     // withdraw directly to curve LP token, this is what we primarily use
   71 |     |     function withdrawAndUnwrap(uint256 _amount, bool _claim)
   72 |     |         external
   73 |     |         returns (bool);
   74 |     | 
   75 |     |     // claim rewards, with an option to claim extra rewards or not
   76 |     |     function getReward(address _account, bool _claimExtras)
   77 |     |         external
   78 |     |         returns (bool);
   79 |     | }
   80 |     | 
   81 |     | // Part: ICurveFi
   82 |     | 
   83 |     | interface ICurveFi {
   84 |     |     function get_virtual_price() external view returns (uint256);
   85 |     | 
   86 |     |     function add_liquidity(
   87 |     |         // Iron bank pool
   88 |     |         uint256[2] calldata amounts,
   89 |     |         uint256 min_mint_amount
   90 |     |     ) external payable;
   91 |     | 
   92 |     |     function remove_liquidity_imbalance(
   93 |     |         uint256[2] calldata amounts,
   94 |     |         uint256 max_burn_amount
   95 |     |     ) external;
   96 |     | 
   97 |     |     function remove_liquidity(uint256 _amount, uint256[2] calldata amounts)
   98 |     |         external;
   99 |     | 
  100 |     |     function remove_liquidity_one_coin(
  101 |     |         uint256 _token_amount,
  102 |     |         int128 i,
  103 |     |         uint256 min_amount
  104 |     |     ) external;
  105 |     | 
  106 |     |     function exchange(
  107 |     |         int128 from,
  108 |     |         int128 to,
  109 |     |         uint256 _from_amount,
  110 |     |         uint256 _min_to_amount
  111 |     |     ) external;
  112 |     | 
  113 |     |     function balances(uint256) external view returns (uint256);
  114 |     | 
  115 |     |     function get_dy(
  116 |     |         int128 from,
  117 |     |         int128 to,
  118 |     |         uint256 _from_amount
  119 |     |     ) external view returns (uint256);
  120 |     | 
  121 |     |     function calc_token_amount(uint256[2] calldata amounts, bool _is_deposit)
  122 |     |         external
  123 |     |         view
  124 |     |         returns (uint256);
  125 |     | 
  126 |     |     function calc_withdraw_one_coin(uint256 amount, int128 i)
  127 |     |         external
  128 |     |         view
  129 |     |         returns (uint256);
  130 |     | }
  131 |     | 
  132 |     | // Part: IOracle
  133 |     | 
  134 |     | interface IOracle {
  135 |     |     function ethToAsset(
  136 |     |         uint256 _ethAmountIn,
  137 |     |         address _tokenOut,
  138 |     |         uint32 _twapPeriod
  139 |     |     ) external view returns (uint256 amountOut);
  140 |     | }
  141 |     | 
  142 |     | // Part: IUniV3
  143 |     | 
  144 |     | interface IUniV3 {
  145 |     |     struct ExactInputParams {
  146 |     |         bytes path;
  147 |     |         address recipient;
  148 |     |         uint256 deadline;
  149 |     |         uint256 amountIn;
  150 |     |         uint256 amountOutMinimum;
  151 |     |     }
  152 |     | 
  153 |     |     function exactInput(ExactInputParams calldata params)
  154 |     |         external
  155 |     |         payable
  156 |     |         returns (uint256 amountOut);
  157 |     | }
  158 |     | 
  159 |     | // Part: IUniswapV2Router01
  160 |     | 
  161 |     | interface IUniswapV2Router01 {
  162 |     |     function factory() external pure returns (address);
  163 |     | 
  164 |     |     function WETH() external pure returns (address);
  165 |     | 
  166 |     |     function addLiquidity(
  167 |     |         address tokenA,
  168 |     |         address tokenB,
  169 |     |         uint256 amountADesired,
  170 |     |         uint256 amountBDesired,
  171 |     |         uint256 amountAMin,
  172 |     |         uint256 amountBMin,
  173 |     |         address to,
  174 |     |         uint256 deadline
  175 |     |     )
  176 |     |         external
  177 |     |         returns (
  178 |     |             uint256 amountA,
  179 |     |             uint256 amountB,
  180 |     |             uint256 liquidity
  181 |     |         );
  182 |     | 
  183 |     |     function addLiquidityETH(
  184 |     |         address token,
  185 |     |         uint256 amountTokenDesired,
  186 |     |         uint256 amountTokenMin,
  187 |     |         uint256 amountETHMin,
  188 |     |         address to,
  189 |     |         uint256 deadline
  190 |     |     )
  191 |     |         external
  192 |     |         payable
  193 |     |         returns (
  194 |     |             uint256 amountToken,
  195 |     |             uint256 amountETH,
  196 |     |             uint256 liquidity
  197 |     |         );
  198 |     | 
  199 |     |     function removeLiquidity(
  200 |     |         address tokenA,
  201 |     |         address tokenB,
  202 |     |         uint256 liquidity,
  203 |     |         uint256 amountAMin,
  204 |     |         uint256 amountBMin,
  205 |     |         address to,
  206 |     |         uint256 deadline
  207 |     |     ) external returns (uint256 amountA, uint256 amountB);
  208 |     | 
  209 |     |     function removeLiquidityETH(
  210 |     |         address token,
  211 |     |         uint256 liquidity,
  212 |     |         uint256 amountTokenMin,
  213 |     |         uint256 amountETHMin,
  214 |     |         address to,
  215 |     |         uint256 deadline
  216 |     |     ) external returns (uint256 amountToken, uint256 amountETH);
  217 |     | 
  218 |     |     function removeLiquidityWithPermit(
  219 |     |         address tokenA,
  220 |     |         address tokenB,
  221 |     |         uint256 liquidity,
  222 |     |         uint256 amountAMin,
  223 |     |         uint256 amountBMin,
  224 |     |         address to,
  225 |     |         uint256 deadline,
  226 |     |         bool approveMax,
  227 |     |         uint8 v,
  228 |     |         bytes32 r,
  229 |     |         bytes32 s
  230 |     |     ) external returns (uint256 amountA, uint256 amountB);
  231 |     | 
  232 |     |     function removeLiquidityETHWithPermit(
  233 |     |         address token,
  234 |     |         uint256 liquidity,
  235 |     |         uint256 amountTokenMin,
  236 |     |         uint256 amountETHMin,
  237 |     |         address to,
  238 |     |         uint256 deadline,
  239 |     |         bool approveMax,
  240 |     |         uint8 v,
  241 |     |         bytes32 r,
  242 |     |         bytes32 s
  243 |     |     ) external returns (uint256 amountToken, uint256 amountETH);
  244 |     | 
  245 |     |     function swapExactTokensForTokens(
  246 |     |         uint256 amountIn,
  247 |     |         uint256 amountOutMin,
  248 |     |         address[] calldata path,
  249 |     |         address to,
  250 |     |         uint256 deadline
  251 |     |     ) external returns (uint256[] memory amounts);
  252 |     | 
  253 |     |     function swapTokensForExactTokens(
  254 |     |         uint256 amountOut,
  255 |     |         uint256 amountInMax,
  256 |     |         address[] calldata path,
  257 |     |         address to,
  258 |     |         uint256 deadline
  259 |     |     ) external returns (uint256[] memory amounts);
  260 |     | 
  261 |     |     function swapExactETHForTokens(
  262 |     |         uint256 amountOutMin,
  263 |     |         address[] calldata path,
  264 |     |         address to,
  265 |     |         uint256 deadline
  266 |     |     ) external payable returns (uint256[] memory amounts);
  267 |     | 
  268 |     |     function swapTokensForExactETH(
  269 |     |         uint256 amountOut,
  270 |     |         uint256 amountInMax,
  271 |     |         address[] calldata path,
  272 |     |         address to,
  273 |     |         uint256 deadline
  274 |     |     ) external returns (uint256[] memory amounts);
  275 |     | 
  276 |     |     function swapExactTokensForETH(
  277 |     |         uint256 amountIn,
  278 |     |         uint256 amountOutMin,
  279 |     |         address[] calldata path,
  280 |     |         address to,
  281 |     |         uint256 deadline
  282 |     |     ) external returns (uint256[] memory amounts);
  283 |     | 
  284 |     |     function swapETHForExactTokens(
  285 |     |         uint256 amountOut,
  286 |     |         address[] calldata path,
  287 |     |         address to,
  288 |     |         uint256 deadline
  289 |     |     ) external payable returns (uint256[] memory amounts);
  290 |     | 
  291 |     |     function quote(
  292 |     |         uint256 amountA,
  293 |     |         uint256 reserveA,
  294 |     |         uint256 reserveB
  295 |     |     ) external pure returns (uint256 amountB);
  296 |     | 
  297 |     |     function getAmountOut(
  298 |     |         uint256 amountIn,
  299 |     |         uint256 reserveIn,
  300 |     |         uint256 reserveOut
  301 |     |     ) external pure returns (uint256 amountOut);
  302 |     | 
  303 |     |     function getAmountIn(
  304 |     |         uint256 amountOut,
  305 |     |         uint256 reserveIn,
  306 |     |         uint256 reserveOut
  307 |     |     ) external pure returns (uint256 amountIn);
  308 |     | 
  309 |     |     function getAmountsOut(uint256 amountIn, address[] calldata path)
  310 |     |         external
  311 |     |         view
  312 |     |         returns (uint256[] memory amounts);
  313 |     | 
  314 |     |     function getAmountsIn(uint256 amountOut, address[] calldata path)
  315 |     |         external
  316 |     |         view
  317 |     |         returns (uint256[] memory amounts);
  318 |     | }
  319 |     | 
  320 |     | // Part: OpenZeppelin/openzeppelin-contracts@3.1.0/Address
  321 |     | 
  322 |     | /**
  323 |     |  * @dev Collection of functions related to the address type
  324 |     |  */
  325 |     | library Address {
  326 |     |     /**
  327 |     |      * @dev Returns true if `account` is a contract.
  328 |     |      *
  329 |     |      * [IMPORTANT]
  330 |     |      * ====
  331 |     |      * It is unsafe to assume that an address for which this function returns
  332 |     |      * false is an externally-owned account (EOA) and not a contract.
  333 |     |      *
  334 |     |      * Among others, `isContract` will return false for the following
  335 |     |      * types of addresses:
  336 |     |      *
  337 |     |      *  - an externally-owned account
  338 |     |      *  - a contract in construction
  339 |     |      *  - an address where a contract will be created
  340 |     |      *  - an address where a contract lived, but was destroyed
  341 |     |      * ====
  342 |     |      */
  343 |     |     function isContract(address account) internal view returns (bool) {
  344 |     |         // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
  345 |     |         // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
  346 |     |         // for accounts without code, i.e. `keccak256('')`
  347 |     |         bytes32 codehash;
  348 |     |         bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
  349 |     |         // solhint-disable-next-line no-inline-assembly
  350 |     |         assembly { codehash := extcodehash(account) }
  351 |     |         return (codehash != accountHash && codehash != 0x0);
  352 |     |     }
  353 |     | 
  354 |     |     /**
  355 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  356 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  357 |     |      *
  358 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  359 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  360 |     |      * imposed by `transfer`, making them unable to receive funds via
  361 |     |      * `transfer`. {sendValue} removes this limitation.
  362 |     |      *
  363 |     |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  364 |     |      *
  365 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  366 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  367 |     |      * {ReentrancyGuard} or the
  368 |     |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  369 |     |      */
  370 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  371 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  372 |     | 
  373 |     |         // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
  374 |     |         (bool success, ) = recipient.call{ value: amount }("");
  375 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  376 |     |     }
  377 |     | 
  378 |     |     /**
  379 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  380 |     |      * plain`call` is an unsafe replacement for a function call: use this
  381 |     |      * function instead.
  382 |     |      *
  383 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  384 |     |      * function (like regular Solidity function calls).
  385 |     |      *
  386 |     |      * Returns the raw returned data. To convert to the expected return value,
  387 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  388 |     |      *
  389 |     |      * Requirements:
  390 |     |      *
  391 |     |      * - `target` must be a contract.
  392 |     |      * - calling `target` with `data` must not revert.
  393 |     |      *
  394 |     |      * _Available since v3.1._
  395 |     |      */
  396 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  397 |     |       return functionCall(target, data, "Address: low-level call failed");
  398 |     |     }
  399 |     | 
  400 |     |     /**
  401 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  402 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  403 |     |      *
  404 |     |      * _Available since v3.1._
  405 |     |      */
  406 |     |     function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
  407 |     |         return _functionCallWithValue(target, data, 0, errorMessage);
  408 |     |     }
  409 |     | 
  410 |     |     /**
  411 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  412 |     |      * but also transferring `value` wei to `target`.
  413 |     |      *
  414 |     |      * Requirements:
  415 |     |      *
  416 |     |      * - the calling contract must have an ETH balance of at least `value`.
  417 |     |      * - the called Solidity function must be `payable`.
  418 |     |      *
  419 |     |      * _Available since v3.1._
  420 |     |      */
  421 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  422 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
  423 |     |     }
  424 |     | 
  425 |     |     /**
  426 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
  427 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
  428 |     |      *
  429 |     |      * _Available since v3.1._
  430 |     |      */
  431 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
  432 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
  433 |     |         return _functionCallWithValue(target, data, value, errorMessage);
  434 |     |     }
  435 |     | 
  436 |     |     function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
  437 |     |         require(isContract(target), "Address: call to non-contract");
  438 |     | 
  439 |     |         // solhint-disable-next-line avoid-low-level-calls
  440 |     |         (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
  441 |     |         if (success) {
  442 |     |             return returndata;
  443 |     |         } else {
  444 |     |             // Look for revert reason and bubble it up if present
  445 |     |             if (returndata.length > 0) {
  446 |     |                 // The easiest way to bubble the revert reason is using memory via assembly
  447 |     | 
  448 |     |                 // solhint-disable-next-line no-inline-assembly
  449 |     |                 assembly {
  450 |     |                     let returndata_size := mload(returndata)
  451 |     |                     revert(add(32, returndata), returndata_size)
  452 |     |                 }
  453 |     |             } else {
  454 |     |                 revert(errorMessage);
  455 |     |             }
  456 |     |         }
  457 |     |     }
  458 |     | }
  459 |     | 
  460 |     | // Part: OpenZeppelin/openzeppelin-contracts@3.1.0/IERC20
  461 |     | 
  462 |     | /**
  463 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  464 |     |  */
  465 |     | interface IERC20 {
  466 |     |     /**
  467 |     |      * @dev Returns the amount of tokens in existence.
  468 |     |      */
  469 |     |     function totalSupply() external view returns (uint256);
  470 |     | 
  471 |     |     /**
  472 |     |      * @dev Returns the amount of tokens owned by `account`.
  473 |     |      */
  474 |     |     function balanceOf(address account) external view returns (uint256);
  475 |     | 
  476 |     |     /**
  477 |     |      * @dev Moves `amount` tokens from the caller's account to `recipient`.
  478 |     |      *
  479 |     |      * Returns a boolean value indicating whether the operation succeeded.
  480 |     |      *
  481 |     |      * Emits a {Transfer} event.
  482 |     |      */
  483 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
  484 |     | 
  485 |     |     /**
  486 |     |      * @dev Returns the remaining number of tokens that `spender` will be
  487 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
  488 |     |      * zero by default.
  489 |     |      *
  490 |     |      * This value changes when {approve} or {transferFrom} are called.
  491 |     |      */
  492 |     |     function allowance(address owner, address spender) external view returns (uint256);
  493 |     | 
  494 |     |     /**
  495 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
  496 |     |      *
  497 |     |      * Returns a boolean value indicating whether the operation succeeded.
  498 |     |      *
  499 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
  500 |     |      * that someone may use both the old and the new allowance by unfortunate
  501 |     |      * transaction ordering. One possible solution to mitigate this race
  502 |     |      * condition is to first reduce the spender's allowance to 0 and set the
  503 |     |      * desired value afterwards:
  504 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
  505 |     |      *
  506 |     |      * Emits an {Approval} event.
  507 |     |      */
  508 |     |     function approve(address spender, uint256 amount) external returns (bool);
  509 |     | 
  510 |     |     /**
  511 |     |      * @dev Moves `amount` tokens from `sender` to `recipient` using the
  512 |     |      * allowance mechanism. `amount` is then deducted from the caller's
  513 |     |      * allowance.
  514 |     |      *
  515 |     |      * Returns a boolean value indicating whether the operation succeeded.
  516 |     |      *
  517 |     |      * Emits a {Transfer} event.
  518 |     |      */
  519 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
  520 |     | 
  521 |     |     /**
  522 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
  523 |     |      * another (`to`).
  524 |     |      *
  525 |     |      * Note that `value` may be zero.
  526 |     |      */
  527 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  528 |     | 
  529 |     |     /**
  530 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
  531 |     |      * a call to {approve}. `value` is the new allowance.
  532 |     |      */
  533 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  534 |     | }
  535 |     | 
  536 |     | // Part: OpenZeppelin/openzeppelin-contracts@3.1.0/Math
  537 |     | 
  538 |     | /**
  539 |     |  * @dev Standard math utilities missing in the Solidity language.
  540 |     |  */
  541 |     | library Math {
  542 |     |     /**
  543 |     |      * @dev Returns the largest of two numbers.
  544 |     |      */
  545 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  546 |     |         return a >= b ? a : b;
  547 |     |     }
  548 |     | 
  549 |     |     /**
  550 |     |      * @dev Returns the smallest of two numbers.
  551 |     |      */
  552 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  553 |     |         return a < b ? a : b;
  554 |     |     }
  555 |     | 
  556 |     |     /**
  557 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  558 |     |      * zero.
  559 |     |      */
  560 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  561 |     |         // (a + b) / 2 can overflow, so we distribute
  562 |     |         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
  563 |     |     }
  564 |     | }
  565 |     | 
  566 |     | // Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeMath
  567 |     | 
  568 |     | /**
  569 |     |  * @dev Wrappers over Solidity's arithmetic operations with added overflow
  570 |     |  * checks.
  571 |     |  *
  572 |     |  * Arithmetic operations in Solidity wrap on overflow. This can easily result
  573 |     |  * in bugs, because programmers usually assume that an overflow raises an
  574 |     |  * error, which is the standard behavior in high level programming languages.
  575 |     |  * `SafeMath` restores this intuition by reverting the transaction when an
  576 |     |  * operation overflows.
  577 |     |  *
  578 |     |  * Using this library instead of the unchecked operations eliminates an entire
  579 |     |  * class of bugs, so it's recommended to use it always.
  580 |     |  */
  581 |     | library SafeMath {
  582 |     |     /**
  583 |     |      * @dev Returns the addition of two unsigned integers, reverting on
  584 |     |      * overflow.
  585 |     |      *
  586 |     |      * Counterpart to Solidity's `+` operator.
  587 |     |      *
  588 |     |      * Requirements:
  589 |     |      *
  590 |     |      * - Addition cannot overflow.
  591 |     |      */
  592 |     |     function add(uint256 a, uint256 b) internal pure returns (uint256) {
  593 |     |         uint256 c = a + b;
  594 |     |         require(c >= a, "SafeMath: addition overflow");
  595 |     | 
  596 |     |         return c;
  597 |     |     }
  598 |     | 
  599 |     |     /**
  600 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
  601 |     |      * overflow (when the result is negative).
  602 |     |      *
  603 |     |      * Counterpart to Solidity's `-` operator.
  604 |     |      *
  605 |     |      * Requirements:
  606 |     |      *
  607 |     |      * - Subtraction cannot overflow.
  608 |     |      */
  609 |     |     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
  610 |     |         return sub(a, b, "SafeMath: subtraction overflow");
  611 |     |     }
  612 |     | 
  613 |     |     /**
  614 |     |      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
  615 |     |      * overflow (when the result is negative).
  616 |     |      *
  617 |     |      * Counterpart to Solidity's `-` operator.
  618 |     |      *
  619 |     |      * Requirements:
  620 |     |      *
  621 |     |      * - Subtraction cannot overflow.
  622 |     |      */
  623 |     |     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
  624 |     |         require(b <= a, errorMessage);
  625 |     |         uint256 c = a - b;
  626 |     | 
  627 |     |         return c;
  628 |     |     }
  629 |     | 
  630 |     |     /**
  631 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
  632 |     |      * overflow.
  633 |     |      *
  634 |     |      * Counterpart to Solidity's `*` operator.
  635 |     |      *
  636 |     |      * Requirements:
  637 |     |      *
  638 |     |      * - Multiplication cannot overflow.
  639 |     |      */
  640 |     |     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
  641 |     |         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
  642 |     |         // benefit is lost if 'b' is also tested.
  643 |     |         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
  644 |     |         if (a == 0) {
  645 |     |             return 0;
  646 |     |         }
  647 |     | 
  648 |     |         uint256 c = a * b;
  649 |     |         require(c / a == b, "SafeMath: multiplication overflow");
  650 |     | 
  651 |     |         return c;
  652 |     |     }
  653 |     | 
  654 |     |     /**
  655 |     |      * @dev Returns the integer division of two unsigned integers. Reverts on
  656 |     |      * division by zero. The result is rounded towards zero.
  657 |     |      *
  658 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
  659 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
  660 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
  661 |     |      *
  662 |     |      * Requirements:
  663 |     |      *
  664 |     |      * - The divisor cannot be zero.
  665 |     |      */
  666 |     |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
  667 |     |         return div(a, b, "SafeMath: division by zero");
  668 |     |     }
  669 |     | 
  670 |     |     /**
  671 |     |      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
  672 |     |      * division by zero. The result is rounded towards zero.
  673 |     |      *
  674 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
  675 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
  676 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
  677 |     |      *
  678 |     |      * Requirements:
  679 |     |      *
  680 |     |      * - The divisor cannot be zero.
  681 |     |      */
  682 |     |     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
  683 |     |         require(b > 0, errorMessage);
  684 |     |         uint256 c = a / b;
  685 |     |         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
  686 |     | 
  687 |     |         return c;
  688 |     |     }
  689 |     | 
  690 |     |     /**
  691 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
  692 |     |      * Reverts when dividing by zero.
  693 |     |      *
  694 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
  695 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
  696 |     |      * invalid opcode to revert (consuming all remaining gas).
  697 |     |      *
  698 |     |      * Requirements:
  699 |     |      *
  700 |     |      * - The divisor cannot be zero.
  701 |     |      */
  702 |     |     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
  703 |     |         return mod(a, b, "SafeMath: modulo by zero");
  704 |     |     }
  705 |     | 
  706 |     |     /**
  707 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
  708 |     |      * Reverts with custom message when dividing by zero.
  709 |     |      *
  710 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
  711 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
  712 |     |      * invalid opcode to revert (consuming all remaining gas).
  713 |     |      *
  714 |     |      * Requirements:
  715 |     |      *
  716 |     |      * - The divisor cannot be zero.
  717 |     |      */
  718 |     |     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
  719 |     |         require(b != 0, errorMessage);
  720 |     |         return a % b;
  721 |     |     }
  722 |     | }
  723 |     | 
  724 |     | // Part: yearn/yearn-vaults@0.4.3/HealthCheck
  725 |     | 
  726 |     | interface HealthCheck {
  727 |     |     function check(
  728 |     |         uint256 profit,
  729 |     |         uint256 loss,
  730 |     |         uint256 debtPayment,
  731 |     |         uint256 debtOutstanding,
  732 |     |         uint256 totalDebt
  733 |     |     ) external view returns (bool);
  734 |     | }
  735 |     | 
  736 |     | // Part: IUniswapV2Router02
  737 |     | 
  738 |     | interface IUniswapV2Router02 is IUniswapV2Router01 {
  739 |     |     function removeLiquidityETHSupportingFeeOnTransferTokens(
  740 |     |         address token,
  741 |     |         uint256 liquidity,
  742 |     |         uint256 amountTokenMin,
  743 |     |         uint256 amountETHMin,
  744 |     |         address to,
  745 |     |         uint256 deadline
  746 |     |     ) external returns (uint256 amountETH);
  747 |     | 
  748 |     |     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
  749 |     |         address token,
  750 |     |         uint256 liquidity,
  751 |     |         uint256 amountTokenMin,
  752 |     |         uint256 amountETHMin,
  753 |     |         address to,
  754 |     |         uint256 deadline,
  755 |     |         bool approveMax,
  756 |     |         uint8 v,
  757 |     |         bytes32 r,
  758 |     |         bytes32 s
  759 |     |     ) external returns (uint256 amountETH);
  760 |     | 
  761 |     |     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
  762 |     |         uint256 amountIn,
  763 |     |         uint256 amountOutMin,
  764 |     |         address[] calldata path,
  765 |     |         address to,
  766 |     |         uint256 deadline
  767 |     |     ) external;
  768 |     | 
  769 |     |     function swapExactETHForTokensSupportingFeeOnTransferTokens(
  770 |     |         uint256 amountOutMin,
  771 |     |         address[] calldata path,
  772 |     |         address to,
  773 |     |         uint256 deadline
  774 |     |     ) external payable;
  775 |     | 
  776 |     |     function swapExactTokensForETHSupportingFeeOnTransferTokens(
  777 |     |         uint256 amountIn,
  778 |     |         uint256 amountOutMin,
  779 |     |         address[] calldata path,
  780 |     |         address to,
  781 |     |         uint256 deadline
  782 |     |     ) external;
  783 |     | }
  784 |     | 
  785 |     | // Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeERC20
  786 |     | 
  787 |     | /**
  788 |     |  * @title SafeERC20
  789 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  790 |     |  * contract returns false). Tokens that return no value (and instead revert or
  791 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  792 |     |  * successful.
  793 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  794 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  795 |     |  */
  796 |     | library SafeERC20 {
  797 |     |     using SafeMath for uint256;
  798 |     |     using Address for address;
  799 |     | 
  800 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  801 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  802 |     |     }
  803 |     | 
  804 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  805 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  806 |     |     }
  807 |     | 
  808 |     |     /**
  809 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  810 |     |      * {IERC20-approve}, and its usage is discouraged.
  811 |     |      *
  812 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  813 |     |      * {safeDecreaseAllowance} instead.
  814 |     |      */
  815 |     |     function safeApprove(IERC20 token, address spender, uint256 value) internal {
  816 |     |         // safeApprove should only be called when setting an initial allowance,
  817 |     |         // or when resetting it to zero. To increase and decrease it, use
  818 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  819 |     |         // solhint-disable-next-line max-line-length
  820 |     |         require((value == 0) || (token.allowance(address(this), spender) == 0),
  821 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  822 |     |         );
  823 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  824 |     |     }
  825 |     | 
  826 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  827 |     |         uint256 newAllowance = token.allowance(address(this), spender).add(value);
  828 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
  829 |     |     }
  830 |     | 
  831 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  832 |     |         uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
  833 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
  834 |     |     }
  835 |     | 
  836 |     |     /**
  837 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
  838 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
  839 |     |      * @param token The token targeted by the call.
  840 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
  841 |     |      */
  842 |     |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
  843 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
  844 |     |         // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
  845 |     |         // the target address contains contract code and also asserts for success in the low-level call.
  846 |     | 
  847 |     |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
  848 |     |         if (returndata.length > 0) { // Return data is optional
  849 |     |             // solhint-disable-next-line max-line-length
  850 |     |             require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
  851 |     |         }
  852 |     |     }
  853 |     | }
  854 |     | 
  855 |     | // Part: yearn/yearn-vaults@0.4.3/VaultAPI
  856 |     | 
  857 |     | interface VaultAPI is IERC20 {
  858 |     |     function name() external view returns (string calldata);
  859 |     | 
  860 |     |     function symbol() external view returns (string calldata);
  861 |     | 
  862 |     |     function decimals() external view returns (uint256);
  863 |     | 
  864 |     |     function apiVersion() external pure returns (string memory);
  865 |     | 
  866 |     |     function permit(
  867 |     |         address owner,
  868 |     |         address spender,
  869 |     |         uint256 amount,
  870 |     |         uint256 expiry,
  871 |     |         bytes calldata signature
  872 |     |     ) external returns (bool);
  873 |     | 
  874 |     |     // NOTE: Vyper produces multiple signatures for a given function with "default" args
  875 |     |     function deposit() external returns (uint256);
  876 |     | 
  877 |     |     function deposit(uint256 amount) external returns (uint256);
  878 |     | 
  879 |     |     function deposit(uint256 amount, address recipient) external returns (uint256);
  880 |     | 
  881 |     |     // NOTE: Vyper produces multiple signatures for a given function with "default" args
  882 |     |     function withdraw() external returns (uint256);
  883 |     | 
  884 |     |     function withdraw(uint256 maxShares) external returns (uint256);
  885 |     | 
  886 |     |     function withdraw(uint256 maxShares, address recipient) external returns (uint256);
  887 |     | 
  888 |     |     function token() external view returns (address);
  889 |     | 
  890 |     |     function strategies(address _strategy) external view returns (StrategyParams memory);
  891 |     | 
  892 |     |     function pricePerShare() external view returns (uint256);
  893 |     | 
  894 |     |     function totalAssets() external view returns (uint256);
  895 |     | 
  896 |     |     function depositLimit() external view returns (uint256);
  897 |     | 
  898 |     |     function maxAvailableShares() external view returns (uint256);
  899 |     | 
  900 |     |     /**
  901 |     |      * View how much the Vault would increase this Strategy's borrow limit,
  902 |     |      * based on its present performance (since its last report). Can be used to
  903 |     |      * determine expectedReturn in your Strategy.
  904 |     |      */
  905 |     |     function creditAvailable() external view returns (uint256);
  906 |     | 
  907 |     |     /**
  908 |     |      * View how much the Vault would like to pull back from the Strategy,
  909 |     |      * based on its present performance (since its last report). Can be used to
  910 |     |      * determine expectedReturn in your Strategy.
  911 |     |      */
  912 |     |     function debtOutstanding() external view returns (uint256);
  913 |     | 
  914 |     |     /**
  915 |     |      * View how much the Vault expect this Strategy to return at the current
  916 |     |      * block, based on its present performance (since its last report). Can be
  917 |     |      * used to determine expectedReturn in your Strategy.
  918 |     |      */
  919 |     |     function expectedReturn() external view returns (uint256);
  920 |     | 
  921 |     |     /**
  922 |     |      * This is the main contact point where the Strategy interacts with the
  923 |     |      * Vault. It is critical that this call is handled as intended by the
  924 |     |      * Strategy. Therefore, this function will be called by BaseStrategy to
  925 |     |      * make sure the integration is correct.
  926 |     |      */
  927 |     |     function report(
  928 |     |         uint256 _gain,
  929 |     |         uint256 _loss,
  930 |     |         uint256 _debtPayment
  931 |     |     ) external returns (uint256);
  932 |     | 
  933 |     |     /**
  934 |     |      * This function should only be used in the scenario where the Strategy is
  935 |     |      * being retired but no migration of the positions are possible, or in the
  936 |     |      * extreme scenario that the Strategy needs to be put into "Emergency Exit"
  937 |     |      * mode in order for it to exit as quickly as possible. The latter scenario
  938 |     |      * could be for any reason that is considered "critical" that the Strategy
  939 |     |      * exits its position as fast as possible, such as a sudden change in
  940 |     |      * market conditions leading to losses, or an imminent failure in an
  941 |     |      * external dependency.
  942 |     |      */
  943 |     |     function revokeStrategy() external;
  944 |     | 
  945 |     |     /**
  946 |     |      * View the governance address of the Vault to assert privileged functions
  947 |     |      * can only be called by governance. The Strategy serves the Vault, so it
  948 |     |      * is subject to governance defined by the Vault.
  949 |     |      */
  950 |     |     function governance() external view returns (address);
  951 |     | 
  952 |     |     /**
  953 |     |      * View the management address of the Vault to assert privileged functions
  954 |     |      * can only be called by management. The Strategy serves the Vault, so it
  955 |     |      * is subject to management defined by the Vault.
  956 |     |      */
  957 |     |     function management() external view returns (address);
  958 |     | 
  959 |     |     /**
  960 |     |      * View the guardian address of the Vault to assert privileged functions
  961 |     |      * can only be called by guardian. The Strategy serves the Vault, so it
  962 |     |      * is subject to guardian defined by the Vault.
  963 |     |      */
  964 |     |     function guardian() external view returns (address);
  965 |     | }
  966 |     | 
  967 |     | // Part: yearn/yearn-vaults@0.4.3/BaseStrategy
  968 |     | 
  969 |     | /**
  970 |     |  * @title Yearn Base Strategy
  971 |     |  * @author yearn.finance
  972 |     |  * @notice
  973 |     |  *  BaseStrategy implements all of the required functionality to interoperate
  974 |     |  *  closely with the Vault contract. This contract should be inherited and the
  975 |     |  *  abstract methods implemented to adapt the Strategy to the particular needs
  976 |     |  *  it has to create a return.
  977 |     |  *
  978 |     |  *  Of special interest is the relationship between `harvest()` and
  979 |     |  *  `vault.report()'. `harvest()` may be called simply because enough time has
  980 |     |  *  elapsed since the last report, and not because any funds need to be moved
  981 |     |  *  or positions adjusted. This is critical so that the Vault may maintain an
  982 |     |  *  accurate picture of the Strategy's performance. See  `vault.report()`,
  983 |     |  *  `harvest()`, and `harvestTrigger()` for further details.
  984 |     |  */
  985 |     | 
  986 |     | abstract contract BaseStrategy {
  987 |     |     using SafeMath for uint256;
  988 |     |     using SafeERC20 for IERC20;
  989 |     |     string public metadataURI;
  990 |     | 
  991 |     |     // health checks
  992 |     |     bool public doHealthCheck;
  993 |     |     address public healthCheck;
  994 |     | 
  995 |     |     /**
  996 |     |      * @notice
  997 |     |      *  Used to track which version of `StrategyAPI` this Strategy
  998 |     |      *  implements.
  999 |     |      * @dev The Strategy's version must match the Vault's `API_VERSION`.
 1000 |     |      * @return A string which holds the current API version of this contract.
 1001 |     |      */
 1002 |     |     function apiVersion() public pure returns (string memory) {
 1003 |     |         return "0.4.3";
 1004 |     |     }
 1005 |     | 
 1006 |     |     /**
 1007 |     |      * @notice This Strategy's name.
 1008 |     |      * @dev
 1009 |     |      *  You can use this field to manage the "version" of this Strategy, e.g.
 1010 |     |      *  `StrategySomethingOrOtherV1`. However, "API Version" is managed by
 1011 |     |      *  `apiVersion()` function above.
 1012 |     |      * @return This Strategy's name.
 1013 |     |      */
 1014 |     |     function name() external view virtual returns (string memory);
 1015 |     | 
 1016 |     |     /**
 1017 |     |      * @notice
 1018 |     |      *  The amount (priced in want) of the total assets managed by this strategy should not count
 1019 |     |      *  towards Yearn's TVL calculations.
 1020 |     |      * @dev
 1021 |     |      *  You can override this field to set it to a non-zero value if some of the assets of this
 1022 |     |      *  Strategy is somehow delegated inside another part of of Yearn's ecosystem e.g. another Vault.
 1023 |     |      *  Note that this value must be strictly less than or equal to the amount provided by
 1024 |     |      *  `estimatedTotalAssets()` below, as the TVL calc will be total assets minus delegated assets.
 1025 |     |      *  Also note that this value is used to determine the total assets under management by this
 1026 |     |      *  strategy, for the purposes of computing the management fee in `Vault`
 1027 |     |      * @return
 1028 |     |      *  The amount of assets this strategy manages that should not be included in Yearn's Total Value
 1029 |     |      *  Locked (TVL) calculation across it's ecosystem.
 1030 |     |      */
 1031 |     |     function delegatedAssets() external view virtual returns (uint256) {
 1032 |     |         return 0;
 1033 |     |     }
 1034 |     | 
 1035 |     |     VaultAPI public vault;
 1036 |     |     address public strategist;
 1037 |     |     address public rewards;
 1038 |     |     address public keeper;
 1039 |     | 
 1040 |     |     IERC20 public want;
 1041 |     | 
 1042 |     |     // So indexers can keep track of this
 1043 |     |     event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);
 1044 |     | 
 1045 |     |     event UpdatedStrategist(address newStrategist);
 1046 |     | 
 1047 |     |     event UpdatedKeeper(address newKeeper);
 1048 |     | 
 1049 |     |     event UpdatedRewards(address rewards);
 1050 |     | 
 1051 |     |     event UpdatedMinReportDelay(uint256 delay);
 1052 |     | 
 1053 |     |     event UpdatedMaxReportDelay(uint256 delay);
 1054 |     | 
 1055 |     |     event UpdatedProfitFactor(uint256 profitFactor);
 1056 |     | 
 1057 |     |     event UpdatedDebtThreshold(uint256 debtThreshold);
 1058 |     | 
 1059 |     |     event EmergencyExitEnabled();
 1060 |     | 
 1061 |     |     event UpdatedMetadataURI(string metadataURI);
 1062 |     | 
 1063 |     |     // The minimum number of seconds between harvest calls. See
 1064 |     |     // `setMinReportDelay()` for more details.
 1065 |     |     uint256 public minReportDelay;
 1066 |     | 
 1067 |     |     // The maximum number of seconds between harvest calls. See
 1068 |     |     // `setMaxReportDelay()` for more details.
 1069 |     |     uint256 public maxReportDelay;
 1070 |     | 
 1071 |     |     // The minimum multiple that `callCost` must be above the credit/profit to
 1072 |     |     // be "justifiable". See `setProfitFactor()` for more details.
 1073 |     |     uint256 public profitFactor;
 1074 |     | 
 1075 |     |     // Use this to adjust the threshold at which running a debt causes a
 1076 |     |     // harvest trigger. See `setDebtThreshold()` for more details.
 1077 |     |     uint256 public debtThreshold;
 1078 |     | 
 1079 |     |     // See note on `setEmergencyExit()`.
 1080 |     |     bool public emergencyExit;
 1081 |     | 
 1082 |     |     // modifiers
 1083 |     |     modifier onlyAuthorized() {
 1084 |     |         require(msg.sender == strategist || msg.sender == governance(), "!authorized");
 1085 |     |         _;
 1086 |     |     }
 1087 |     | 
 1088 |     |     modifier onlyEmergencyAuthorized() {
 1089 |     |         require(
 1090 |     |             msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(),
 1091 |     |             "!authorized"
 1092 |     |         );
 1093 |     |         _;
 1094 |     |     }
 1095 |     | 
 1096 |     |     modifier onlyStrategist() {
 1097 |     |         require(msg.sender == strategist, "!strategist");
 1098 |     |         _;
 1099 |     |     }
 1100 |     | 
 1101 |     |     modifier onlyGovernance() {
 1102 |     |         require(msg.sender == governance(), "!authorized");
 1103 |     |         _;
 1104 |     |     }
 1105 |     | 
 1106 |     |     modifier onlyKeepers() {
 1107 |     |         require(
 1108 |     |             msg.sender == keeper ||
 1109 |     |                 msg.sender == strategist ||
 1110 |     |                 msg.sender == governance() ||
 1111 |     |                 msg.sender == vault.guardian() ||
 1112 |     |                 msg.sender == vault.management(),
 1113 |     |             "!authorized"
 1114 |     |         );
 1115 |     |         _;
 1116 |     |     }
 1117 |     | 
 1118 |     |     modifier onlyVaultManagers() {
 1119 |     |         require(msg.sender == vault.management() || msg.sender == governance(), "!authorized");
 1120 |     |         _;
 1121 |     |     }
 1122 |     | 
 1123 |     |     constructor(address _vault) public {
 1124 |     |         _initialize(_vault, msg.sender, msg.sender, msg.sender);
 1125 |     |     }
 1126 |     | 
 1127 |     |     /**
 1128 |     |      * @notice
 1129 |     |      *  Initializes the Strategy, this is called only once, when the
 1130 |     |      *  contract is deployed.
 1131 |     |      * @dev `_vault` should implement `VaultAPI`.
 1132 |     |      * @param _vault The address of the Vault responsible for this Strategy.
 1133 |     |      * @param _strategist The address to assign as `strategist`.
 1134 |     |      * The strategist is able to change the reward address
 1135 |     |      * @param _rewards  The address to use for pulling rewards.
 1136 |     |      * @param _keeper The adddress of the _keeper. _keeper
 1137 |     |      * can harvest and tend a strategy.
 1138 |     |      */
 1139 |     |     function _initialize(
 1140 |     |         address _vault,
 1141 |     |         address _strategist,
 1142 |     |         address _rewards,
 1143 |     |         address _keeper
 1144 |     |     ) internal {
 1145 |     |         require(address(want) == address(0), "Strategy already initialized");
 1146 |     | 
 1147 |     |         vault = VaultAPI(_vault);
 1148 |     |         want = IERC20(vault.token());
 1149 |     |         want.safeApprove(_vault, uint256(-1)); // Give Vault unlimited access (might save gas)
 1150 |     |         strategist = _strategist;
 1151 |     |         rewards = _rewards;
 1152 |     |         keeper = _keeper;
 1153 |     | 
 1154 |     |         // initialize variables
 1155 |     |         minReportDelay = 0;
 1156 |     |         maxReportDelay = 86400;
 1157 |     |         profitFactor = 100;
 1158 |     |         debtThreshold = 0;
 1159 |     | 
 1160 |     |         vault.approve(rewards, uint256(-1)); // Allow rewards to be pulled
 1161 |     |     }
 1162 |     | 
 1163 |     |     function setHealthCheck(address _healthCheck) external onlyVaultManagers {
 1164 |     |         healthCheck = _healthCheck;
 1165 |     |     }
 1166 |     | 
 1167 |     |     function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {
 1168 |     |         doHealthCheck = _doHealthCheck;
 1169 |     |     }
 1170 |     | 
 1171 |     |     /**
 1172 |     |      * @notice
 1173 |     |      *  Used to change `strategist`.
 1174 |     |      *
 1175 |     |      *  This may only be called by governance or the existing strategist.
 1176 |     |      * @param _strategist The new address to assign as `strategist`.
 1177 |     |      */
 1178 |     |     function setStrategist(address _strategist) external onlyAuthorized {
 1179 |     |         require(_strategist != address(0));
 1180 |     |         strategist = _strategist;
 1181 |     |         emit UpdatedStrategist(_strategist);
 1182 |     |     }
 1183 |     | 
 1184 |     |     /**
 1185 |     |      * @notice
 1186 |     |      *  Used to change `keeper`.
 1187 |     |      *
 1188 |     |      *  `keeper` is the only address that may call `tend()` or `harvest()`,
 1189 |     |      *  other than `governance()` or `strategist`. However, unlike
 1190 |     |      *  `governance()` or `strategist`, `keeper` may *only* call `tend()`
 1191 |     |      *  and `harvest()`, and no other authorized functions, following the
 1192 |     |      *  principle of least privilege.
 1193 |     |      *
 1194 |     |      *  This may only be called by governance or the strategist.
 1195 |     |      * @param _keeper The new address to assign as `keeper`.
 1196 |     |      */
 1197 |     |     function setKeeper(address _keeper) external onlyAuthorized {
 1198 |     |         require(_keeper != address(0));
 1199 |     |         keeper = _keeper;
 1200 |     |         emit UpdatedKeeper(_keeper);
 1201 |     |     }
 1202 |     | 
 1203 |     |     /**
 1204 |     |      * @notice
 1205 |     |      *  Used to change `rewards`. EOA or smart contract which has the permission
 1206 |     |      *  to pull rewards from the vault.
 1207 |     |      *
 1208 |     |      *  This may only be called by the strategist.
 1209 |     |      * @param _rewards The address to use for pulling rewards.
 1210 |     |      */
 1211 |     |     function setRewards(address _rewards) external onlyStrategist {
 1212 |     |         require(_rewards != address(0));
 1213 |     |         vault.approve(rewards, 0);
 1214 |     |         rewards = _rewards;
 1215 |     |         vault.approve(rewards, uint256(-1));
 1216 |     |         emit UpdatedRewards(_rewards);
 1217 |     |     }
 1218 |     | 
 1219 |     |     /**
 1220 |     |      * @notice
 1221 |     |      *  Used to change `minReportDelay`. `minReportDelay` is the minimum number
 1222 |     |      *  of blocks that should pass for `harvest()` to be called.
 1223 |     |      *
 1224 |     |      *  For external keepers (such as the Keep3r network), this is the minimum
 1225 |     |      *  time between jobs to wait. (see `harvestTrigger()`
 1226 |     |      *  for more details.)
 1227 |     |      *
 1228 |     |      *  This may only be called by governance or the strategist.
 1229 |     |      * @param _delay The minimum number of seconds to wait between harvests.
 1230 |     |      */
 1231 |     |     function setMinReportDelay(uint256 _delay) external onlyAuthorized {
 1232 |     |         minReportDelay = _delay;
 1233 |     |         emit UpdatedMinReportDelay(_delay);
 1234 |     |     }
 1235 |     | 
 1236 |     |     /**
 1237 |     |      * @notice
 1238 |     |      *  Used to change `maxReportDelay`. `maxReportDelay` is the maximum number
 1239 |     |      *  of blocks that should pass for `harvest()` to be called.
 1240 |     |      *
 1241 |     |      *  For external keepers (such as the Keep3r network), this is the maximum
 1242 |     |      *  time between jobs to wait. (see `harvestTrigger()`
 1243 |     |      *  for more details.)
 1244 |     |      *
 1245 |     |      *  This may only be called by governance or the strategist.
 1246 |     |      * @param _delay The maximum number of seconds to wait between harvests.
 1247 |     |      */
 1248 |     |     function setMaxReportDelay(uint256 _delay) external onlyAuthorized {
 1249 |     |         maxReportDelay = _delay;
 1250 |     |         emit UpdatedMaxReportDelay(_delay);
 1251 |     |     }
 1252 |     | 
 1253 |     |     /**
 1254 |     |      * @notice
 1255 |     |      *  Used to change `profitFactor`. `profitFactor` is used to determine
 1256 |     |      *  if it's worthwhile to harvest, given gas costs. (See `harvestTrigger()`
 1257 |     |      *  for more details.)
 1258 |     |      *
 1259 |     |      *  This may only be called by governance or the strategist.
 1260 |     |      * @param _profitFactor A ratio to multiply anticipated
 1261 |     |      * `harvest()` gas cost against.
 1262 |     |      */
 1263 |     |     function setProfitFactor(uint256 _profitFactor) external onlyAuthorized {
 1264 |     |         profitFactor = _profitFactor;
 1265 |     |         emit UpdatedProfitFactor(_profitFactor);
 1266 |     |     }
 1267 |     | 
 1268 |     |     /**
 1269 |     |      * @notice
 1270 |     |      *  Sets how far the Strategy can go into loss without a harvest and report
 1271 |     |      *  being required.
 1272 |     |      *
 1273 |     |      *  By default this is 0, meaning any losses would cause a harvest which
 1274 |     |      *  will subsequently report the loss to the Vault for tracking. (See
 1275 |     |      *  `harvestTrigger()` for more details.)
 1276 |     |      *
 1277 |     |      *  This may only be called by governance or the strategist.
 1278 |     |      * @param _debtThreshold How big of a loss this Strategy may carry without
 1279 |     |      * being required to report to the Vault.
 1280 |     |      */
 1281 |     |     function setDebtThreshold(uint256 _debtThreshold) external onlyAuthorized {
 1282 |     |         debtThreshold = _debtThreshold;
 1283 |     |         emit UpdatedDebtThreshold(_debtThreshold);
 1284 |     |     }
 1285 |     | 
 1286 |     |     /**
 1287 |     |      * @notice
 1288 |     |      *  Used to change `metadataURI`. `metadataURI` is used to store the URI
 1289 |     |      * of the file describing the strategy.
 1290 |     |      *
 1291 |     |      *  This may only be called by governance or the strategist.
 1292 |     |      * @param _metadataURI The URI that describe the strategy.
 1293 |     |      */
 1294 |     |     function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {
 1295 |     |         metadataURI = _metadataURI;
 1296 |     |         emit UpdatedMetadataURI(_metadataURI);
 1297 |     |     }
 1298 |     | 
 1299 |     |     /**
 1300 |     |      * Resolve governance address from Vault contract, used to make assertions
 1301 |     |      * on protected functions in the Strategy.
 1302 |     |      */
 1303 |     |     function governance() internal view returns (address) {
 1304 |     |         return vault.governance();
 1305 |     |     }
 1306 |     | 
 1307 |     |     /**
 1308 |     |      * @notice
 1309 |     |      *  Provide an accurate conversion from `_amtInWei` (denominated in wei)
 1310 |     |      *  to `want` (using the native decimal characteristics of `want`).
 1311 |     |      * @dev
 1312 |     |      *  Care must be taken when working with decimals to assure that the conversion
 1313 |     |      *  is compatible. As an example:
 1314 |     |      *
 1315 |     |      *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),
 1316 |     |      *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)
 1317 |     |      *
 1318 |     |      * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`
 1319 |     |      * @return The amount in `want` of `_amtInEth` converted to `want`
 1320 |     |      **/
 1321 |     |     function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);
 1322 |     | 
 1323 |     |     /**
 1324 |     |      * @notice
 1325 |     |      *  Provide an accurate estimate for the total amount of assets
 1326 |     |      *  (principle + return) that this Strategy is currently managing,
 1327 |     |      *  denominated in terms of `want` tokens.
 1328 |     |      *
 1329 |     |      *  This total should be "realizable" e.g. the total value that could
 1330 |     |      *  *actually* be obtained from this Strategy if it were to divest its
 1331 |     |      *  entire position based on current on-chain conditions.
 1332 |     |      * @dev
 1333 |     |      *  Care must be taken in using this function, since it relies on external
 1334 |     |      *  systems, which could be manipulated by the attacker to give an inflated
 1335 |     |      *  (or reduced) value produced by this function, based on current on-chain
 1336 |     |      *  conditions (e.g. this function is possible to influence through
 1337 |     |      *  flashloan attacks, oracle manipulations, or other DeFi attack
 1338 |     |      *  mechanisms).
 1339 |     |      *
 1340 |     |      *  It is up to governance to use this function to correctly order this
 1341 |     |      *  Strategy relative to its peers in the withdrawal queue to minimize
 1342 |     |      *  losses for the Vault based on sudden withdrawals. This value should be
 1343 |     |      *  higher than the total debt of the Strategy and higher than its expected
 1344 |     |      *  value to be "safe".
 1345 |     |      * @return The estimated total assets in this Strategy.
 1346 |     |      */
 1347 |     |     function estimatedTotalAssets() public view virtual returns (uint256);
 1348 |     | 
 1349 |     |     /*
 1350 |     |      * @notice
 1351 |     |      *  Provide an indication of whether this strategy is currently "active"
 1352 |     |      *  in that it is managing an active position, or will manage a position in
 1353 |     |      *  the future. This should correlate to `harvest()` activity, so that Harvest
 1354 |     |      *  events can be tracked externally by indexing agents.
 1355 |     |      * @return True if the strategy is actively managing a position.
 1356 |     |      */
 1357 |     |     function isActive() public view returns (bool) {
 1358 |     |         return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;
 1359 |     |     }
 1360 |     | 
 1361 |     |     /**
 1362 |     |      * Perform any Strategy unwinding or other calls necessary to capture the
 1363 |     |      * "free return" this Strategy has generated since the last time its core
 1364 |     |      * position(s) were adjusted. Examples include unwrapping extra rewards.
 1365 |     |      * This call is only used during "normal operation" of a Strategy, and
 1366 |     |      * should be optimized to minimize losses as much as possible.
 1367 |     |      *
 1368 |     |      * This method returns any realized profits and/or realized losses
 1369 |     |      * incurred, and should return the total amounts of profits/losses/debt
 1370 |     |      * payments (in `want` tokens) for the Vault's accounting (e.g.
 1371 |     |      * `want.balanceOf(this) >= _debtPayment + _profit`).
 1372 |     |      *
 1373 |     |      * `_debtOutstanding` will be 0 if the Strategy is not past the configured
 1374 |     |      * debt limit, otherwise its value will be how far past the debt limit
 1375 |     |      * the Strategy is. The Strategy's debt limit is configured in the Vault.
 1376 |     |      *
 1377 |     |      * NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.
 1378 |     |      *       It is okay for it to be less than `_debtOutstanding`, as that
 1379 |     |      *       should only used as a guide for how much is left to pay back.
 1380 |     |      *       Payments should be made to minimize loss from slippage, debt,
 1381 |     |      *       withdrawal fees, etc.
 1382 |     |      *
 1383 |     |      * See `vault.debtOutstanding()`.
 1384 |     |      */
 1385 |     |     function prepareReturn(uint256 _debtOutstanding)
 1386 |     |         internal
 1387 |     |         virtual
 1388 |     |         returns (
 1389 |     |             uint256 _profit,
 1390 |     |             uint256 _loss,
 1391 |     |             uint256 _debtPayment
 1392 |     |         );
 1393 |     | 
 1394 |     |     /**
 1395 |     |      * Perform any adjustments to the core position(s) of this Strategy given
 1396 |     |      * what change the Vault made in the "investable capital" available to the
 1397 |     |      * Strategy. Note that all "free capital" in the Strategy after the report
 1398 |     |      * was made is available for reinvestment. Also note that this number
 1399 |     |      * could be 0, and you should handle that scenario accordingly.
 1400 |     |      *
 1401 |     |      * See comments regarding `_debtOutstanding` on `prepareReturn()`.
 1402 |     |      */
 1403 |     |     function adjustPosition(uint256 _debtOutstanding) internal virtual;
 1404 |     | 
 1405 |     |     /**
 1406 |     |      * Liquidate up to `_amountNeeded` of `want` of this strategy's positions,
 1407 |     |      * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.
 1408 |     |      * This function should return the amount of `want` tokens made available by the
 1409 |     |      * liquidation. If there is a difference between them, `_loss` indicates whether the
 1410 |     |      * difference is due to a realized loss, or if there is some other sitution at play
 1411 |     |      * (e.g. locked funds) where the amount made available is less than what is needed.
 1412 |     |      *
 1413 |     |      * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained
 1414 |     |      */
 1415 |     |     function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);
 1416 |     | 
 1417 |     |     /**
 1418 |     |      * Liquidate everything and returns the amount that got freed.
 1419 |     |      * This function is used during emergency exit instead of `prepareReturn()` to
 1420 |     |      * liquidate all of the Strategy's positions back to the Vault.
 1421 |     |      */
 1422 |     | 
 1423 |     |     function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);
 1424 |     | 
 1425 |     |     /**
 1426 |     |      * @notice
 1427 |     |      *  Provide a signal to the keeper that `tend()` should be called. The
 1428 |     |      *  keeper will provide the estimated gas cost that they would pay to call
 1429 |     |      *  `tend()`, and this function should use that estimate to make a
 1430 |     |      *  determination if calling it is "worth it" for the keeper. This is not
 1431 |     |      *  the only consideration into issuing this trigger, for example if the
 1432 |     |      *  position would be negatively affected if `tend()` is not called
 1433 |     |      *  shortly, then this can return `true` even if the keeper might be
 1434 |     |      *  "at a loss" (keepers are always reimbursed by Yearn).
 1435 |     |      * @dev
 1436 |     |      *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).
 1437 |     |      *
 1438 |     |      *  This call and `harvestTrigger()` should never return `true` at the same
 1439 |     |      *  time.
 1440 |     |      * @param callCostInWei The keeper's estimated gas cost to call `tend()` (in wei).
 1441 |     |      * @return `true` if `tend()` should be called, `false` otherwise.
 1442 |     |      */
 1443 |     |     function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {
 1444 |     |         // We usually don't need tend, but if there are positions that need
 1445 |     |         // active maintainence, overriding this function is how you would
 1446 |     |         // signal for that.
 1447 |     |         // If your implementation uses the cost of the call in want, you can
 1448 |     |         // use uint256 callCost = ethToWant(callCostInWei);
 1449 |     | 
 1450 |     |         return false;
 1451 |     |     }
 1452 |     | 
 1453 |     |     /**
 1454 |     |      * @notice
 1455 |     |      *  Adjust the Strategy's position. The purpose of tending isn't to
 1456 |     |      *  realize gains, but to maximize yield by reinvesting any returns.
 1457 |     |      *
 1458 |     |      *  See comments on `adjustPosition()`.
 1459 |     |      *
 1460 |     |      *  This may only be called by governance, the strategist, or the keeper.
 1461 |     |      */
 1462 |     |     function tend() external onlyKeepers {
 1463 |     |         // Don't take profits with this call, but adjust for better gains
 1464 |     |         adjustPosition(vault.debtOutstanding());
 1465 |     |     }
 1466 |     | 
 1467 |     |     /**
 1468 |     |      * @notice
 1469 |     |      *  Provide a signal to the keeper that `harvest()` should be called. The
 1470 |     |      *  keeper will provide the estimated gas cost that they would pay to call
 1471 |     |      *  `harvest()`, and this function should use that estimate to make a
 1472 |     |      *  determination if calling it is "worth it" for the keeper. This is not
 1473 |     |      *  the only consideration into issuing this trigger, for example if the
 1474 |     |      *  position would be negatively affected if `harvest()` is not called
 1475 |     |      *  shortly, then this can return `true` even if the keeper might be "at a
 1476 |     |      *  loss" (keepers are always reimbursed by Yearn).
 1477 |     |      * @dev
 1478 |     |      *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).
 1479 |     |      *
 1480 |     |      *  This call and `tendTrigger` should never return `true` at the
 1481 |     |      *  same time.
 1482 |     |      *
 1483 |     |      *  See `min/maxReportDelay`, `profitFactor`, `debtThreshold` to adjust the
 1484 |     |      *  strategist-controlled parameters that will influence whether this call
 1485 |     |      *  returns `true` or not. These parameters will be used in conjunction
 1486 |     |      *  with the parameters reported to the Vault (see `params`) to determine
 1487 |     |      *  if calling `harvest()` is merited.
 1488 |     |      *
 1489 |     |      *  It is expected that an external system will check `harvestTrigger()`.
 1490 |     |      *  This could be a script run off a desktop or cloud bot (e.g.
 1491 |     |      *  https://github.com/iearn-finance/yearn-vaults/blob/main/scripts/keep.py),
 1492 |     |      *  or via an integration with the Keep3r network (e.g.
 1493 |     |      *  https://github.com/Macarse/GenericKeep3rV2/blob/master/contracts/keep3r/GenericKeep3rV2.sol).
 1494 |     |      * @param callCostInWei The keeper's estimated gas cost to call `harvest()` (in wei).
 1495 |     |      * @return `true` if `harvest()` should be called, `false` otherwise.
 1496 |     |      */
 1497 |     |     function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {
 1498 |     |         uint256 callCost = ethToWant(callCostInWei);
 1499 |     |         StrategyParams memory params = vault.strategies(address(this));
 1500 |     | 
 1501 |     |         // Should not trigger if Strategy is not activated
 1502 |     |         if (params.activation == 0) return false;
 1503 |     | 
 1504 |     |         // Should not trigger if we haven't waited long enough since previous harvest
 1505 |     |         if (block.timestamp.sub(params.lastReport) < minReportDelay) return false;
 1506 |     | 
 1507 |     |         // Should trigger if hasn't been called in a while
 1508 |     |         if (block.timestamp.sub(params.lastReport) >= maxReportDelay) return true;
 1509 |     | 
 1510 |     |         // If some amount is owed, pay it back
 1511 |     |         // NOTE: Since debt is based on deposits, it makes sense to guard against large
 1512 |     |         //       changes to the value from triggering a harvest directly through user
 1513 |     |         //       behavior. This should ensure reasonable resistance to manipulation
 1514 |     |         //       from user-initiated withdrawals as the outstanding debt fluctuates.
 1515 |     |         uint256 outstanding = vault.debtOutstanding();
 1516 |     |         if (outstanding > debtThreshold) return true;
 1517 |     | 
 1518 |     |         // Check for profits and losses
 1519 |     |         uint256 total = estimatedTotalAssets();
 1520 |     |         // Trigger if we have a loss to report
 1521 |     |         if (total.add(debtThreshold) < params.totalDebt) return true;
 1522 |     | 
 1523 |     |         uint256 profit = 0;
 1524 |     |         if (total > params.totalDebt) profit = total.sub(params.totalDebt); // We've earned a profit!
 1525 |     | 
 1526 |     |         // Otherwise, only trigger if it "makes sense" economically (gas cost
 1527 |     |         // is <N% of value moved)
 1528 |     |         uint256 credit = vault.creditAvailable();
 1529 |     |         return (profitFactor.mul(callCost) < credit.add(profit));
 1530 |     |     }
 1531 |     | 
 1532 |     |     /**
 1533 |     |      * @notice
 1534 |     |      *  Harvests the Strategy, recognizing any profits or losses and adjusting
 1535 |     |      *  the Strategy's position.
 1536 |     |      *
 1537 |     |      *  In the rare case the Strategy is in emergency shutdown, this will exit
 1538 |     |      *  the Strategy's position.
 1539 |     |      *
 1540 |     |      *  This may only be called by governance, the strategist, or the keeper.
 1541 |     |      * @dev
 1542 |     |      *  When `harvest()` is called, the Strategy reports to the Vault (via
 1543 |     |      *  `vault.report()`), so in some cases `harvest()` must be called in order
 1544 |     |      *  to take in profits, to borrow newly available funds from the Vault, or
 1545 |     |      *  otherwise adjust its position. In other cases `harvest()` must be
 1546 |     |      *  called to report to the Vault on the Strategy's position, especially if
 1547 |     |      *  any losses have occurred.
 1548 |     |      */
 1549 |     |     function harvest() external onlyKeepers {
 1550 |     |         uint256 profit = 0;
 1551 |     |         uint256 loss = 0;
 1552 |     |         uint256 debtOutstanding = vault.debtOutstanding();
 1553 |     |         uint256 debtPayment = 0;
 1554 |     |         if (emergencyExit) {
 1555 |     |             // Free up as much capital as possible
 1556 |     |             uint256 amountFreed = liquidateAllPositions();
 1557 |     |             if (amountFreed < debtOutstanding) {
 1558 |     |                 loss = debtOutstanding.sub(amountFreed);
 1559 |     |             } else if (amountFreed > debtOutstanding) {
 1560 |     |                 profit = amountFreed.sub(debtOutstanding);
 1561 |     |             }
 1562 |     |             debtPayment = debtOutstanding.sub(loss);
 1563 |     |         } else {
 1564 |     |             // Free up returns for Vault to pull
 1565 |     |             (profit, loss, debtPayment) = prepareReturn(debtOutstanding);
 1566 |     |         }
 1567 |     | 
 1568 |     |         // Allow Vault to take up to the "harvested" balance of this contract,
 1569 |     |         // which is the amount it has earned since the last time it reported to
 1570 |     |         // the Vault.
 1571 |     |         uint256 totalDebt = vault.strategies(address(this)).totalDebt;
 1572 |     |         debtOutstanding = vault.report(profit, loss, debtPayment);
 1573 |     | 
 1574 |     |         // Check if free returns are left, and re-invest them
 1575 |     |         adjustPosition(debtOutstanding);
 1576 |     | 
 1577 |     |         // call healthCheck contract
 1578 |     |         if (doHealthCheck && healthCheck != address(0)) {
 1579 |     |             require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), "!healthcheck");
 1580 |     |         } else {
 1581 |     |             doHealthCheck = true;
 1582 |     |         }
 1583 |     | 
 1584 |     |         emit Harvested(profit, loss, debtPayment, debtOutstanding);
 1585 |     |     }
 1586 |     | 
 1587 |     |     /**
 1588 |     |      * @notice
 1589 |     |      *  Withdraws `_amountNeeded` to `vault`.
 1590 |     |      *
 1591 |     |      *  This may only be called by the Vault.
 1592 |     |      * @param _amountNeeded How much `want` to withdraw.
 1593 |     |      * @return _loss Any realized losses
 1594 |     |      */
 1595 |     |     function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {
 1596 |     |         require(msg.sender == address(vault), "!vault");
 1597 |     |         // Liquidate as much as possible to `want`, up to `_amountNeeded`
 1598 |     |         uint256 amountFreed;
 1599 |     |         (amountFreed, _loss) = liquidatePosition(_amountNeeded);
 1600 |     |         // Send it directly back (NOTE: Using `msg.sender` saves some gas here)
 1601 |     |         want.safeTransfer(msg.sender, amountFreed);
 1602 |     |         // NOTE: Reinvest anything leftover on next `tend`/`harvest`
 1603 |     |     }
 1604 |     | 
 1605 |     |     /**
 1606 |     |      * Do anything necessary to prepare this Strategy for migration, such as
 1607 |     |      * transferring any reserve or LP tokens, CDPs, or other tokens or stores of
 1608 |     |      * value.
 1609 |     |      */
 1610 |     |     function prepareMigration(address _newStrategy) internal virtual;
 1611 |     | 
 1612 |     |     /**
 1613 |     |      * @notice
 1614 |     |      *  Transfers all `want` from this Strategy to `_newStrategy`.
 1615 |     |      *
 1616 |     |      *  This may only be called by the Vault.
 1617 |     |      * @dev
 1618 |     |      * The new Strategy's Vault must be the same as this Strategy's Vault.
 1619 |     |      *  The migration process should be carefully performed to make sure all
 1620 |     |      * the assets are migrated to the new address, which should have never
 1621 |     |      * interacted with the vault before.
 1622 |     |      * @param _newStrategy The Strategy to migrate to.
 1623 |     |      */
 1624 |     |     function migrate(address _newStrategy) external {
 1625 |     |         require(msg.sender == address(vault));
 1626 |     |         require(BaseStrategy(_newStrategy).vault() == vault);
 1627 |     |         prepareMigration(_newStrategy);
 1628 |     |         want.safeTransfer(_newStrategy, want.balanceOf(address(this)));
 1629 |     |     }
 1630 |     | 
 1631 |     |     /**
 1632 |     |      * @notice
 1633 |     |      *  Activates emergency exit. Once activated, the Strategy will exit its
 1634 |     |      *  position upon the next harvest, depositing all funds into the Vault as
 1635 |     |      *  quickly as is reasonable given on-chain conditions.
 1636 |     |      *
 1637 |     |      *  This may only be called by governance or the strategist.
 1638 |     |      * @dev
 1639 |     |      *  See `vault.setEmergencyShutdown()` and `harvest()` for further details.
 1640 |     |      */
 1641 |     |     function setEmergencyExit() external onlyEmergencyAuthorized {
 1642 |     |         emergencyExit = true;
 1643 |     |         vault.revokeStrategy();
 1644 |     | 
 1645 |     |         emit EmergencyExitEnabled();
 1646 |     |     }
 1647 |     | 
 1648 |     |     /**
 1649 |     |      * Override this to add all tokens/tokenized positions this contract
 1650 |     |      * manages on a *persistent* basis (e.g. not just for swapping back to
 1651 |     |      * want ephemerally).
 1652 |     |      *
 1653 |     |      * NOTE: Do *not* include `want`, already included in `sweep` below.
 1654 |     |      *
 1655 |     |      * Example:
 1656 |     |      * ```
 1657 |     |      *    function protectedTokens() internal override view returns (address[] memory) {
 1658 |     |      *      address[] memory protected = new address[](3);
 1659 |     |      *      protected[0] = tokenA;
 1660 |     |      *      protected[1] = tokenB;
 1661 |     |      *      protected[2] = tokenC;
 1662 |     |      *      return protected;
 1663 |     |      *    }
 1664 |     |      * ```
 1665 |     |      */
 1666 |     |     function protectedTokens() internal view virtual returns (address[] memory);
 1667 |     | 
 1668 |     |     /**
 1669 |     |      * @notice
 1670 |     |      *  Removes tokens from this Strategy that are not the type of tokens
 1671 |     |      *  managed by this Strategy. This may be used in case of accidentally
 1672 |     |      *  sending the wrong kind of token to this Strategy.
 1673 |     |      *
 1674 |     |      *  Tokens will be sent to `governance()`.
 1675 |     |      *
 1676 |     |      *  This will fail if an attempt is made to sweep `want`, or any tokens
 1677 |     |      *  that are protected by this Strategy.
 1678 |     |      *
 1679 |     |      *  This may only be called by governance.
 1680 |     |      * @dev
 1681 |     |      *  Implement `protectedTokens()` to specify any additional tokens that
 1682 |     |      *  should be protected from sweeping in addition to `want`.
 1683 |     |      * @param _token The token to transfer out of this vault.
 1684 |     |      */
 1685 |     |     function sweep(address _token) external onlyGovernance {
 1686 |     |         require(_token != address(want), "!want");
 1687 |     |         require(_token != address(vault), "!shares");
 1688 |     | 
 1689 |     |         address[] memory _protectedTokens = protectedTokens();
 1690 |     |         for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], "!protected");
 1691 |     | 
 1692 |     |         IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));
 1693 |     |     }
 1694 |     | }
 1695 |     | 
 1696 |     | // Part: StrategyConvexBase
 1697 |     | 
 1698 |     | abstract contract StrategyConvexBase is BaseStrategy {
 1699 |     |     using SafeERC20 for IERC20;
 1700 |     |     using Address for address;
 1701 |     |     using SafeMath for uint256;
 1702 |     | 
 1703 |     |     /* ========== STATE VARIABLES ========== */
 1704 |     |     // these should stay the same across different wants.
 1705 |     | 
 1706 |     |     // convex stuff
 1707 |     |     address public constant depositContract =
 1708 |     |         0xF403C135812408BFbE8713b5A23a04b3D48AAE31; // this is the deposit contract that all pools use, aka booster
 1709 |     |     address public rewardsContract; // This is unique to each curve pool
 1710 |     |     uint256 public pid; // this is unique to each pool
 1711 |     | 
 1712 |     |     // keepCRV stuff
 1713 |     |     uint256 public keepCRV; // the percentage of CRV we re-lock for boost (in basis points)
 1714 |     |     address public constant voter = 0xF147b8125d2ef93FB6965Db97D6746952a133934; // Yearn's veCRV voter, we send some extra CRV here
 1715 |     |     uint256 internal constant FEE_DENOMINATOR = 10000; // this means all of our fee values are in bips
 1716 |     | 
 1717 |     |     // Swap stuff
 1718 |     |     address internal constant sushiswap =
 1719 |     |         0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F; // default to sushiswap, more CRV and CVX liquidity there
 1720 |     |     address[] public convexTokenPath; // path to sell CVX
 1721 |     | 
 1722 |     |     IERC20 internal constant crv =
 1723 |     |         IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);
 1724 |     |     IERC20 internal constant convexToken =
 1725 |     |         IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
 1726 |     |     IERC20 internal constant weth =
 1727 |     |         IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
 1728 |     | 
 1729 |     |     // keeper stuff
 1730 |     |     uint256 public harvestProfitNeeded; // we use this to set our dollar target (in USDT) for harvest sells
 1731 |     |     bool internal forceHarvestTriggerOnce; // only set this to true when we want to trigger our keepers to harvest for us
 1732 |     | 
 1733 |     |     string internal stratName; // we use this to be able to adjust our strategy's name
 1734 |     | 
 1735 |     |     // convex-specific variables
 1736 |     |     bool public claimRewards; // boolean if we should always claim rewards when withdrawing, usually withdrawAndUnwrap (generally this should be false)
 1737 |     | 
 1738 |     |     /* ========== CONSTRUCTOR ========== */
 1739 |     | 
 1740 |     |     constructor(address _vault) public BaseStrategy(_vault) {}
 1741 |     | 
 1742 |     |     /* ========== VIEWS ========== */
 1743 |     | 
 1744 |     |     function name() external view override returns (string memory) {
 1745 |     |         return stratName;
 1746 |     |     }
 1747 |     | 
 1748 |     |     function stakedBalance() public view returns (uint256) {
 1749 |     |         // how much want we have staked in Convex
 1750 |     |         return IConvexRewards(rewardsContract).balanceOf(address(this));
 1751 |     |     }
 1752 |     | 
 1753 |     |     function balanceOfWant() public view returns (uint256) {
 1754 |     |         // balance of want sitting in our strategy
 1755 |     |         return want.balanceOf(address(this));
 1756 |     |     }
 1757 |     | 
 1758 |     |     function claimableBalance() public view returns (uint256) {
 1759 |     |         // how much CRV we can claim from the staking contract
 1760 |     |         return IConvexRewards(rewardsContract).earned(address(this));
 1761 |     |     }
 1762 |     | 
 1763 |     |     function estimatedTotalAssets() public view override returns (uint256) {
 1764 |     |         return balanceOfWant().add(stakedBalance());
 1765 |     |     }
 1766 |     | 
 1767 |     |     /* ========== CONSTANT FUNCTIONS ========== */
 1768 |     |     // these should stay the same across different wants.
 1769 |     | 
 1770 |     |     function adjustPosition(uint256 _debtOutstanding) internal override {
 1771 |     |         if (emergencyExit) {
 1772 |     |             return;
 1773 |     |         }
 1774 |     |         // Send all of our Curve pool tokens to be deposited
 1775 |     |         uint256 _toInvest = balanceOfWant();
 1776 |     |         // deposit into convex and stake immediately but only if we have something to invest
 1777 |     |         if (_toInvest > 0) {
 1778 |     |             IConvexDeposit(depositContract).deposit(pid, _toInvest, true);
 1779 |     |         }
 1780 |     |     }
 1781 |     | 
 1782 |     |     function liquidatePosition(uint256 _amountNeeded)
 1783 |     |         internal
 1784 |     |         override
 1785 |     |         returns (uint256 _liquidatedAmount, uint256 _loss)
 1786 |     |     {
 1787 |     |         uint256 _wantBal = balanceOfWant();
 1788 |     |         if (_amountNeeded > _wantBal) {
 1789 |     |             uint256 _stakedBal = stakedBalance();
 1790 |     |             if (_stakedBal > 0) {
 1791 |     |                 IConvexRewards(rewardsContract).withdrawAndUnwrap(
 1792 |     |                     Math.min(_stakedBal, _amountNeeded.sub(_wantBal)),
 1793 |     |                     claimRewards
 1794 |     |                 );
 1795 |     |             }
 1796 |     |             uint256 _withdrawnBal = balanceOfWant();
 1797 |     |             _liquidatedAmount = Math.min(_amountNeeded, _withdrawnBal);
 1798 |     |             _loss = _amountNeeded.sub(_liquidatedAmount);
 1799 |     |         } else {
 1800 |     |             // we have enough balance to cover the liquidation available
 1801 |     |             return (_amountNeeded, 0);
 1802 |     |         }
 1803 |     |     }
 1804 |     | 
 1805 |     |     // fire sale, get rid of it all!
 1806 |     |     function liquidateAllPositions() internal override returns (uint256) {
 1807 |     |         uint256 _stakedBal = stakedBalance();
 1808 |     |         if (_stakedBal > 0) {
 1809 |     |             // don't bother withdrawing zero
 1810 |     |             IConvexRewards(rewardsContract).withdrawAndUnwrap(
 1811 |     |                 _stakedBal,
 1812 |     |                 claimRewards
 1813 |     |             );
 1814 |     |         }
 1815 |     |         return balanceOfWant();
 1816 |     |     }
 1817 |     | 
 1818 |     |     // in case we need to exit into the convex deposit token, this will allow us to do that
 1819 |     |     // make sure to check claimRewards before this step if needed
 1820 |     |     // plan to have gov sweep convex deposit tokens from strategy after this
 1821 |     |     function withdrawToConvexDepositTokens() external onlyAuthorized {
 1822 |     |         uint256 _stakedBal = stakedBalance();
 1823 |     |         if (_stakedBal > 0) {
 1824 |     |             IConvexRewards(rewardsContract).withdraw(_stakedBal, claimRewards);
 1825 |     |         }
 1826 |     |     }
 1827 |     | 
 1828 |     |     // we don't want for these tokens to be swept out. We allow gov to sweep out cvx vault tokens; we would only be holding these if things were really, really rekt.
 1829 |     |     function protectedTokens()
 1830 |     |         internal
 1831 |     |         view
 1832 |     |         override
 1833 |     |         returns (address[] memory)
 1834 |     |     {
 1835 |     |         return new address[](0);
 1836 |     |     }
 1837 |     | 
 1838 |     |     /* ========== SETTERS ========== */
 1839 |     | 
 1840 |     |     // These functions are useful for setting parameters of the strategy that may need to be adjusted.
 1841 |     | 
 1842 |     |     // Set the amount of CRV to be locked in Yearn's veCRV voter from each harvest. Default is 10%.
 1843 |     |     function setKeepCRV(uint256 _keepCRV) external onlyAuthorized {
 1844 |     |         require(_keepCRV <= 10_000);
 1845 |     |         keepCRV = _keepCRV;
 1846 |     |     }
 1847 |     | 
 1848 |     |     // We usually don't need to claim rewards on withdrawals, but might change our mind for migrations etc
 1849 |     |     function setClaimRewards(bool _claimRewards) external onlyAuthorized {
 1850 |     |         claimRewards = _claimRewards;
 1851 |     |     }
 1852 |     | 
 1853 |     |     // This determines when we tell our keepers to harvest based on profit. this is how much in USDT we need to make. remember, 6 decimals!
 1854 |     |     function setHarvestProfitNeeded(uint256 _harvestProfitNeeded)
 1855 |     |         external
 1856 |     |         onlyAuthorized
 1857 |     |     {
 1858 |     |         harvestProfitNeeded = _harvestProfitNeeded;
 1859 |     |     }
 1860 |     | 
 1861 |     |     // This allows us to manually harvest with our keeper as needed
 1862 |     |     function setForceHarvestTriggerOnce(bool _forceHarvestTriggerOnce)
 1863 |     |         external
 1864 |     |         onlyAuthorized
 1865 |     |     {
 1866 |     |         forceHarvestTriggerOnce = _forceHarvestTriggerOnce;
 1867 |     |     }
 1868 |     | }
 1869 |     | 
 1870 |     | // File: StrategyConvexMIMUST.sol
 1871 |     | 
 1872 |     | contract StrategyConvexMIMUST is StrategyConvexBase {
 1873 |     |     /* ========== STATE VARIABLES ========== */
 1874 |     |     // these will likely change across different wants.
 1875 |     | 
 1876 |     |     ICurveFi public curve; // Curve Pool, need this for buying more pool tokens
 1877 |     |     uint256 public maxGasPrice; // this is the max gas price we want our keepers to pay for harvests/tends in gwei
 1878 |     | 
 1879 |     |     // Uniswap stuff
 1880 |     |     IOracle internal constant oracle =
 1881 |     |         IOracle(0x0F1f5A87f99f0918e6C81F16E59F3518698221Ff); // this is only needed for strats that use uniV3 for swaps
 1882 |     |     address internal constant uniswapv3 =
 1883 |     |         0xE592427A0AEce92De3Edee1F18E0157C05861564;
 1884 |     |     IERC20 internal constant usdt = // need this for our expected harvest amount
 1885 |     |         IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
 1886 |     |     IERC20 internal constant usdc =
 1887 |     |         IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
 1888 |     |     IERC20 internal constant ust =
 1889 |     |         IERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);
 1890 |     | 
 1891 |     |     /* ========== CONSTRUCTOR ========== */
 1892 |     | 
 1893 |     |     constructor(
 1894 |     |         address _vault,
 1895 |     |         uint256 _pid,
 1896 |     |         address _curvePool,
 1897 |     |         string memory _name
 1898 |     |     ) public StrategyConvexBase(_vault) {
 1899 |     |         // You can set these parameters on deployment to whatever you want
 1900 |     |         maxReportDelay = 7 days; // 7 days in seconds, if we hit this then harvestTrigger = True
 1901 |     |         debtThreshold = 1 * 1e6; // we shouldn't ever have debt, but set a bit of a buffer
 1902 |     |         profitFactor = 1_000_000; // in this strategy, profitFactor is only used for telling keep3rs when to move funds from vault to strategy
 1903 |     |         harvestProfitNeeded = 80_000 * 1e6; // this is how much in USDT we need to make. remember, 6 decimals!
 1904 |     |         healthCheck = 0xDDCea799fF1699e98EDF118e0629A974Df7DF012; // health.ychad.eth
 1905 |     | 
 1906 |     |         // want = Curve LP
 1907 |     |         want.approve(address(depositContract), type(uint256).max);
 1908 |     |         crv.approve(sushiswap, type(uint256).max);
 1909 |     |         convexToken.approve(sushiswap, type(uint256).max);
 1910 |     | 
 1911 |     |         // set our keepCRV
 1912 |     |         keepCRV = 1000;
 1913 |     | 
 1914 |     |         // this is the pool specific to this vault, used for depositing
 1915 |     |         curve = ICurveFi(_curvePool);
 1916 |     | 
 1917 |     |         // setup our rewards contract
 1918 |     |         pid = _pid; // this is the pool ID on convex, we use this to determine what the reweardsContract address is
 1919 |     |         address lptoken;
 1920 |     |         (lptoken, , , rewardsContract, , ) = IConvexDeposit(depositContract)
 1921 |     |             .poolInfo(_pid);
 1922 |     | 
 1923 |     |         // check that our LP token based on our pid matches our want
 1924 |     |         require(address(lptoken) == address(want));
 1925 |     | 
 1926 |     |         // set our strategy's name
 1927 |     |         stratName = _name;
 1928 |     | 
 1929 |     |         // these are our approvals and path specific to this contract
 1930 |     |         ust.approve(address(curve), type(uint256).max);
 1931 |     |         weth.approve(uniswapv3, type(uint256).max);
 1932 |     | 
 1933 |     |         // set our max gas price
 1934 |     |         maxGasPrice = 100 * 1e9;
 1935 |     |     }
 1936 |     | 
 1937 |     |     /* ========== VARIABLE FUNCTIONS ========== */
 1938 |     |     // these will likely change across different wants.
 1939 |     | 
 1940 |     |     function prepareReturn(uint256 _debtOutstanding)
 1941 |     |         internal
 1942 |     |         override
 1943 |     |         returns (
 1944 |     |             uint256 _profit,
 1945 |     |             uint256 _loss,
 1946 |     |             uint256 _debtPayment
 1947 |     |         )
 1948 |     |     {
 1949 |     |         // if we have anything staked, then harvest CRV and CVX from the rewards contract
 1950 |     |         if (claimableBalance() > 0) {
 1951 |     |             // this claims our CRV, CVX, and any extra tokens like SNX or ANKR. set to false if these tokens don't exist, true if they do.
 1952 |     |             IConvexRewards(rewardsContract).getReward(address(this), false);
 1953 |     | 
 1954 |     |             uint256 crvBalance = crv.balanceOf(address(this));
 1955 |     |             uint256 convexBalance = convexToken.balanceOf(address(this));
 1956 |     | 
 1957 |     |             uint256 _sendToVoter = crvBalance.mul(keepCRV).div(FEE_DENOMINATOR);
 1958 |     |             if (_sendToVoter > 0) {
 1959 |     |                 crv.safeTransfer(voter, _sendToVoter);
 1960 |     |             }
 1961 |     |             uint256 crvRemainder = crvBalance.sub(_sendToVoter);
 1962 |     | 
 1963 |     |             if (crvRemainder > 0) {
 1964 |     |                 _sellCrvforWETH(crvRemainder);
 1965 |     |             }
 1966 |     | 
 1967 |     |             if (convexBalance > 0) {
 1968 |     |                 _sellConvexforWETH(convexBalance);
 1969 |     |             }
 1970 |     | 
 1971 |     |             // convert our WETH to EURt, but don't want to swap dust
 1972 |     |             uint256 _wethBalance = weth.balanceOf(address(this));
 1973 |     |             uint256 _ustBalance = 0;
 1974 |     |             if (_wethBalance > 0) {
 1975 |     |                 _ustBalance = _sellWethForUST(_wethBalance);
 1976 |     |             }
 1977 |     | 
 1978 |     |             // deposit our EURt to Curve if we have any
 1979 |     |             if (_ustBalance > 0) {
 1980 |     |                 curve.add_liquidity([0, _ustBalance], 0);
 1981 |     |             }
 1982 |     |         }
 1983 |     | 
 1984 |     |         // debtOustanding will only be > 0 in the event of revoking or if we need to rebalance from a withdrawal or lowering the debtRatio
 1985 |     |         if (_debtOutstanding > 0) {
 1986 |     |             uint256 _stakedBal = stakedBalance();
 1987 |     |             if (_stakedBal > 0) {
 1988 |     |                 IConvexRewards(rewardsContract).withdrawAndUnwrap(
 1989 |     |                     Math.min(_stakedBal, _debtOutstanding),
 1990 |     |                     claimRewards
 1991 |     |                 );
 1992 |     |             }
 1993 |     |             uint256 _withdrawnBal = balanceOfWant();
 1994 |     |             _debtPayment = Math.min(_debtOutstanding, _withdrawnBal);
 1995 |     |         }
 1996 |     | 
 1997 |     |         // serious loss should never happen, but if it does (for instance, if Curve is hacked), let's record it accurately
 1998 |     |         uint256 assets = estimatedTotalAssets();
 1999 |     |         uint256 debt = vault.strategies(address(this)).totalDebt;
 2000 |     | 
 2001 |     |         // if assets are greater than debt, things are working great!
 2002 |     |         if (assets > debt) {
 2003 |     |             _profit = assets.sub(debt);
 2004 |     |             uint256 _wantBal = balanceOfWant();
 2005 |     |             if (_profit.add(_debtPayment) > _wantBal) {
 2006 |     |                 // this should only be hit following donations to strategy
 2007 |     |                 liquidateAllPositions();
 2008 |     |             }
 2009 |     |         }
 2010 |     |         // if assets are less than debt, we are in trouble
 2011 |     |         else {
 2012 |     |             _loss = debt.sub(assets);
 2013 |     |         }
 2014 |     | 
 2015 |     |         // we're done harvesting, so reset our trigger if we used it
 2016 |     |         forceHarvestTriggerOnce = false;
 2017 |     |     }
 2018 |     | 
 2019 |     |     // Sells our harvested CRV into the selected output.
 2020 |     |     function _sellCrvforWETH(uint256 _amount) internal {
 2021 |     |         address[] memory crvPath = new address[](2);
 2022 |     |         crvPath[0] = address(crv);
 2023 |     |         crvPath[1] = address(weth);
 2024 |     |         IUniswapV2Router02(sushiswap).swapExactTokensForTokens(
 2025 |     |             _amount,
 2026 |     |             uint256(0),
 2027 |     |             crvPath,
 2028 |     |             address(this),
 2029 |     |             block.timestamp
 2030 |     |         );
 2031 |     |     }
 2032 |     | 
 2033 |     |     // Sells our harvested CVX into the selected output.
 2034 |     |     function _sellConvexforWETH(uint256 _amount) internal {
 2035 |     |         address[] memory convexTokenPath = new address[](2);
 2036 |     |         convexTokenPath[0] = address(convexToken);
 2037 |     |         convexTokenPath[1] = address(weth);
 2038 |     |         IUniswapV2Router02(sushiswap).swapExactTokensForTokens(
 2039 |     |             _amount,
 2040 |     |             uint256(0),
 2041 |     |             convexTokenPath,
 2042 |     |             address(this),
 2043 |     |             block.timestamp
 2044 |     |         );
 2045 |     |     }
 2046 |     | 
 2047 |     |     // Sells our WETH for UST
 2048 |     |     function _sellWethForUST(uint256 _amount) internal returns (uint256) {
 2049 |     |         uint256 _eurtOutput =
 2050 |     |             IUniV3(uniswapv3).exactInput(
 2051 |     |                 IUniV3.ExactInputParams(
 2052 |     |                     abi.encodePacked(
 2053 |     |                         address(weth),
 2054 |     |                         uint24(500),
 2055 |     |                         address(usdc),
 2056 |     |                         uint24(500),
 2057 |     |                         address(ust)
 2058 |     |                     ),
 2059 |     |                     address(this),
 2060 |     |                     block.timestamp,
 2061 |     |                     _amount,
 2062 |     |                     uint256(1)
 2063 |     |                 )
 2064 |     |             );
 2065 |     |         return _eurtOutput;
 2066 |     |     }
 2067 |     | 
 2068 |     |     // migrate our want token to a new strategy if needed, make sure to check claimRewards first
 2069 |     |     // also send over any CRV or CVX that is claimed; for migrations we definitely want to claim
 2070 |     |     function prepareMigration(address _newStrategy) internal override {
 2071 |     |         uint256 _stakedBal = stakedBalance();
 2072 |     |         if (_stakedBal > 0) {
 2073 |     |             IConvexRewards(rewardsContract).withdrawAndUnwrap(
 2074 |     |                 _stakedBal,
 2075 |     |                 claimRewards
 2076 |     |             );
 2077 |     |         }
 2078 |     |         crv.safeTransfer(_newStrategy, crv.balanceOf(address(this)));
 2079 |     |         convexToken.safeTransfer(
 2080 |     |             _newStrategy,
 2081 |     |             convexToken.balanceOf(address(this))
 2082 |     |         );
 2083 |     |     }
 2084 |     | 
 2085 |     |     /* ========== KEEP3RS ========== */
 2086 |     | 
 2087 |     |     function harvestTrigger(uint256 callCostinEth)
 2088 |     |         public
 2089 |     |         view
 2090 |     |         override
 2091 |     |         returns (bool)
 2092 |     |     {
 2093 |     |         // trigger if we want to manually harvest
 2094 |     |         if (forceHarvestTriggerOnce) {
 2095 |     |             return true;
 2096 |     |         }
 2097 |     | 
 2098 |     |         // harvest if we have a profit to claim
 2099 |     |         if (claimableProfitInUsdt() > harvestProfitNeeded) {
 2100 |     |             return true;
 2101 |     |         }
 2102 |     | 
 2103 |     |         // Should not trigger if strategy is not active (no assets and no debtRatio). This means we don't need to adjust keeper job.
 2104 |     |         if (!isActive()) {
 2105 |     |             return false;
 2106 |     |         }
 2107 |     | 
 2108 |     |         // check if the base fee gas price is higher than we allow
 2109 |     |         if (readBaseFee() > maxGasPrice) {
 2110 |     |             return false;
 2111 |     |         }
 2112 |     | 
 2113 |     |         return super.harvestTrigger(callCostinEth);
 2114 |     |     }
 2115 |     | 
 2116 |     |     function readBaseFee() internal view returns (uint256 baseFee) {
 2117 |     |         IBaseFee _baseFeeOracle =
 2118 |     |             IBaseFee(0xf8d0Ec04e94296773cE20eFbeeA82e76220cD549);
 2119 |     |         return _baseFeeOracle.basefee_global();
 2120 |     |     }
 2121 |     | 
 2122 |     |     // we will need to add rewards token here if we have them
 2123 |     |     function claimableProfitInUsdt() internal view returns (uint256) {
 2124 |     |         // calculations pulled directly from CVX's contract for minting CVX per CRV claimed
 2125 |     |         uint256 totalCliffs = 1_000;
 2126 |     |         uint256 maxSupply = 100 * 1_000_000 * 1e18; // 100mil
 2127 |     |         uint256 reductionPerCliff = 100_000 * 1e18; // 100,000
 2128 |     |         uint256 supply = convexToken.totalSupply();
 2129 |     |         uint256 mintableCvx;
 2130 |     | 
 2131 |     |         uint256 cliff = supply.div(reductionPerCliff);
 2132 |     |         uint256 _claimableBal = claimableBalance();
 2133 |     |         //mint if below total cliffs
 2134 |     |         if (cliff < totalCliffs) {
 2135 |     |             //for reduction% take inverse of current cliff
 2136 |     |             uint256 reduction = totalCliffs.sub(cliff);
 2137 |     |             //reduce
 2138 |     |             mintableCvx = _claimableBal.mul(reduction).div(totalCliffs);
 2139 |     | 
 2140 |     |             //supply cap check
 2141 |     |             uint256 amtTillMax = maxSupply.sub(supply);
 2142 |     |             if (mintableCvx > amtTillMax) {
 2143 |     |                 mintableCvx = amtTillMax;
 2144 |     |             }
 2145 |     |         }
 2146 |     | 
 2147 |     |         address[] memory crv_usd_path = new address[](3);
 2148 |     |         crv_usd_path[0] = address(crv);
 2149 |     |         crv_usd_path[1] = address(weth);
 2150 |     |         crv_usd_path[2] = address(usdt);
 2151 |     | 
 2152 |     |         address[] memory cvx_usd_path = new address[](3);
 2153 |     |         cvx_usd_path[0] = address(convexToken);
 2154 |     |         cvx_usd_path[1] = address(weth);
 2155 |     |         cvx_usd_path[2] = address(usdt);
 2156 |     | 
 2157 |     |         uint256 crvValue;
 2158 |     |         if (_claimableBal > 0) {
 2159 |     |             uint256[] memory crvSwap =
 2160 |     |                 IUniswapV2Router02(sushiswap).getAmountsOut(
 2161 |     |                     _claimableBal,
 2162 |     |                     crv_usd_path
 2163 |     |                 );
 2164 |     |             crvValue = crvSwap[crvSwap.length - 1];
 2165 |     |         }
 2166 |     | 
 2167 |     |         uint256 cvxValue;
 2168 |     |         if (mintableCvx > 0) {
 2169 |     |             uint256[] memory cvxSwap =
 2170 |     |                 IUniswapV2Router02(sushiswap).getAmountsOut(
 2171 |     |                     mintableCvx,
 2172 |     |                     cvx_usd_path
 2173 |     |                 );
 2174 |     |             cvxValue = cvxSwap[cvxSwap.length - 1];
 2175 |     |         }
 2176 |     |         return crvValue.add(cvxValue);
 2177 |     |     }
 2178 |     | 
 2179 |     |     // convert our keeper's eth cost into want
 2180 |     |     function ethToWant(uint256 _ethAmount)
 2181 |     |         public
 2182 |     |         view
 2183 |     |         override
 2184 |     |         returns (uint256)
 2185 |     |     {
 2186 |     |         uint256 callCostInWant;
 2187 |     |         if (_ethAmount > 0) {
 2188 |     |             uint256 callCostInUst =
 2189 |     |                 oracle.ethToAsset(_ethAmount, address(ust), 1800);
 2190 |     |             callCostInWant = curve.calc_token_amount([0, callCostInUst], true);
 2191 |     |         }
 2192 |     |         return callCostInWant;
 2193 |     |     }
 2194 |     | 
 2195 |     |     /* ========== SETTERS ========== */
 2196 |     | 
 2197 |     |     // set the maximum gas price we want to pay for a harvest/tend in gwei
 2198 |     |     function setGasPrice(uint256 _maxGasPrice) external onlyAuthorized {
 2199 |     |         maxGasPrice = _maxGasPrice.mul(1e9);
 2200 |     |     }
 2201 |     | }

